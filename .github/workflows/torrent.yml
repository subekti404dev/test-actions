name: Docker Torrent Download
on:
  workflow_dispatch:
    inputs:
      url:
        description: 'Torrent file URL'
        required: true
      filename:
        description: 'Optional: rename the discovered video file before upload (e.g. mymovie.mp4 or mymovie.mkv)'
      on_finished:
        description: 'Optional: shell command to run after all steps complete (e.g., curl webhook)'
        required: false
        default: ''

jobs:
  download:
    runs-on: ubuntu-latest
    container: subekti13/torrent-downloader-v2
    steps:
      - name: Load Remote ENV from Protected JSON
        uses: subekti404dev/gha-json-env@v1
        with:
          url: ${{ secrets.ENV_URL }}
          token: ${{ secrets.ENV_TOKEN }}


      - name: Dowload File
        run: torrent download ${{ github.event.inputs.url }}

      - name: LS
        run: tree /data

      - name: Find video file path
        id: find_video
        shell: sh
        run: |
          set -eu
          # Extensions to look for
          exts="mp4 mkv avi mov mpeg mpg m4v webm flv wmv ts m2ts 3gp"
      
          # Build the find conditions
          find_args=""
          first=1
          for ext in $exts; do
            if [ $first -eq 1 ]; then
              find_args="-iname '*.$ext'"
              first=0
            else
              find_args="$find_args -o -iname '*.$ext'"
            fi
          done
      
          # Find all matching files, get their size + path, sort by size (largest first)
          VIDEO_FILE="$(
            eval "find /data -type f \\( $find_args \\) -print0 2>/dev/null" \
            | xargs -0 stat -c "%s %n" \
            | sort -nr \
            | head -n1 \
            | cut -d' ' -f2-
          )"
      
          if [ -z "$VIDEO_FILE" ]; then
            echo "No video files found under /data"
            exit 1
          fi
      
          echo "Selected VIDEO_FILE: $VIDEO_FILE"
          echo "VIDEO_FILE=$VIDEO_FILE" >> "$GITHUB_ENV"

      - name: Rename video file (optional)
        if: ${{ github.event.inputs.filename && github.event.inputs.filename != '' }}
        id: rename_video
        shell: sh
        env:
          VIDEO_FILE: ${{ env.VIDEO_FILE }}
        run: |
          set -eu
          if [ -z "${VIDEO_FILE:-}" ]; then
            echo "VIDEO_FILE is not set"
            exit 1
          fi
          echo "VIDEO_FILE is setted"


          INPUT_NAME="${{ github.event.inputs.filename }}"
          if [ -z "${INPUT_NAME:-}" ]; then
            echo "No filename provided, skipping rename"
            exit 0
          fi
          echo "Filename provided"

          dir="$(dirname "$VIDEO_FILE")"
          base_input="$(basename "$INPUT_NAME")"
          echo "Rename context -> dir='$dir', base_input='$base_input'"
          


          # Normalize extension handling:
          # - Treat names ending with a dot as "no extension" (e.g., "movie.")
          # - If no extension present, reuse the original file's extension (case preserved)
          # - If extension present, use as-is
          orig_ext="${VIDEO_FILE##*.}"
          echo "Rename context -> orig_ext='$orig_ext'"

          # Detect presence of a non-empty extension in base_input
          case "$base_input" in
            *.*)
              # Has a dot; check if the dot is at the end (empty ext)
              if [ "${base_input##*.}" = "$base_input" ] || [ -z "${base_input##*.}" ]; then
                # No real extension after dot -> append original extension
                new_name="${base_input%.*}.${orig_ext}"
              else
                new_name="$base_input"
              fi
              ;;
            *)
              new_name="$base_input.${orig_ext}"
              ;;
          esac
          echo "Rename context -> new_name='$new_name'"

          

          NEW_PATH="$dir/$new_name"
          echo "Rename context -> NEW_PATH='$NEW_PATH'"

          echo "Renaming file to: $NEW_PATH"
          mv -f -- "$VIDEO_FILE" "$NEW_PATH"

          # Update env for subsequent steps
          echo "VIDEO_FILE=$NEW_PATH" >> "$GITHUB_ENV"

      - name: Register file via API
        id: register_file
        shell: sh
        env:
          API_URL: https://api.luxsioab.com/pub/api/local/upload
          API_KEY: ${{ env.torent_downloader_lixstream_api_key }}
          VIDEO_FILE: ${{ env.VIDEO_FILE }}
        run: |
          set -eu
          if [ -z "${VIDEO_FILE:-}" ]; then
            echo "VIDEO_FILE is not set"
            exit 1
          fi
          FILE_NAME="$(basename "$VIDEO_FILE")"
          echo "Registering file: $FILE_NAME to $API_URL"
          RESP="$(curl -sS -X POST -H 'Content-Type: application/json' \
            "$API_URL" \
            --data "{\"key\":\"${API_KEY}\",\"name\":\"${FILE_NAME}\"}")"
          echo "API response: $RESP"

          # Parse expected response fields using jq
          CODE="$(printf '%s' "$RESP" | jq -r '.code // empty' 2>/dev/null || true)"
          UPLOAD_URL="$(printf '%s' "$RESP" | jq -r '.data.url // empty' 2>/dev/null || true)"
          UPLOAD_CT="$(printf '%s' "$RESP" | jq -r '.data.header["Content-Type"] // empty' 2>/dev/null || true)"
          UPLOAD_ID="$(printf '%s' "$RESP" | jq -r '.data.id // empty' 2>/dev/null || true)"

          if [ "${CODE:-}" != "200" ] || [ -z "${UPLOAD_URL:-}" ]; then
            echo "Warning: unexpected API response format or code (code=${CODE:-null}, url=${UPLOAD_URL:-empty})"
          fi

          # Persist raw response and parsed fields for later steps
          printf '%s\n' "API_RESPONSE<<EOF" >> "$GITHUB_ENV"
          printf '%s\n' "$RESP" >> "$GITHUB_ENV"
          printf '%s\n' "EOF" >> "$GITHUB_ENV"
          echo "UPLOAD_URL=$UPLOAD_URL" >> "$GITHUB_ENV"
          echo "UPLOAD_CONTENT_TYPE=$UPLOAD_CT" >> "$GITHUB_ENV"
          echo "UPLOAD_ID=$UPLOAD_ID" >> "$GITHUB_ENV"

          echo "Parsed -> URL: ${UPLOAD_URL:-}, Content-Type: ${UPLOAD_CT:-}, ID: ${UPLOAD_ID:-}"

      - name: Upload file to signed URL
        id: upload_signed_url
        shell: sh
        env:
          UPLOAD_URL: ${{ env.UPLOAD_URL }}
          UPLOAD_CONTENT_TYPE: ${{ env.UPLOAD_CONTENT_TYPE }}
          VIDEO_FILE: ${{ env.VIDEO_FILE }}
        run: |
          set -eu
          if [ -z "${UPLOAD_URL:-}" ] || [ -z "${UPLOAD_CONTENT_TYPE:-}" ] || [ -z "${VIDEO_FILE:-}" ]; then
            echo "Missing required env(s). UPLOAD_URL='${UPLOAD_URL:-}', CONTENT_TYPE='${UPLOAD_CONTENT_TYPE:-}', VIDEO_FILE='${VIDEO_FILE:-}'"
            exit 1
          fi

          # Workaround for curl interpreting [] in URLs as ranges: use --globoff to disable URL globbing.
          # Also quote the URL and path; spaces in VIDEO_FILE are supported by --upload-file.
          echo "Uploading '$VIDEO_FILE' to presigned URL (streaming upload)"
          curl -sS --fail --location --globoff -X PUT "${UPLOAD_URL}" \
            --header "Content-Type: ${UPLOAD_CONTENT_TYPE}" \
            --no-buffer \
            --upload-file "${VIDEO_FILE}"
          echo "Upload completed"

      - name: Callback notify upload result
        id: upload_callback
        shell: sh
        env:
          API_URL_CALLBACK: https://api.luxsioab.com/pub/api/local/upload/callback
          API_KEY: ${{ env.torent_downloader_lixstream_api_key }}
          UPLOAD_ID: ${{ env.UPLOAD_ID }}
        run: |
          set -eu
          if [ -z "${UPLOAD_ID:-}" ]; then
            echo "UPLOAD_ID is not set"
            exit 1
          fi
          echo "Sending upload callback for ID: ${UPLOAD_ID}"
          RESP="$(curl -sS -X POST -H 'Content-Type: application/json' \
            "${API_URL_CALLBACK}" \
            --data "{\"key\":\"${API_KEY}\",\"result\":true,\"id\":\"${UPLOAD_ID}\"}")"

          # Extract fields we need for notifications
          FILE_SHARE_LINK="$(printf '%s' "$RESP" | jq -r '.data.file_share_link // empty' 2>/dev/null || true)"
          FILE_NAME="$(printf '%s' "$RESP" | jq -r '.data.file_name // empty' 2>/dev/null || true)"

          echo "Callback response received. file_share_link length: $(printf '%s' "$FILE_SHARE_LINK" | wc -c), file_name: ${FILE_NAME:-}"

          # Export only the needed fields to environment for next steps
          {
            echo "FILE_SHARE_LINK=$FILE_SHARE_LINK"
            echo "FILE_NAME=$FILE_NAME"
          } >> "$GITHUB_ENV"

      # - name: Send Telegram notification
      #   if: ${{ always() && steps.upload_callback.outcome == 'success' }}
      #   id: notify_telegram
      #   shell: sh
      #   env:
      #     TELEGRAM_BOT_TOKEN: ${{ env.torent_downloader_telegram_bot_token }}
      #     TELEGRAM_CHAT_ID: ${{ env.torent_downloader_telegram_chat_id }}
      #     FILE_SHARE_LINK: ${{ env.FILE_SHARE_LINK }}
      #     FILE_NAME: ${{ env.FILE_NAME }}
      #   run: |
      #     set -eu

      #     if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
      #       echo "Telegram credentials are not set; skipping notification"
      #       exit 0
      #     fi

      #     if [ -z "${FILE_SHARE_LINK:-}" ]; then
      #       echo "FILE_SHARE_LINK not set; skipping notification"
      #       exit 0
      #     fi

      #     TEXT="Upload success:\n ${FILE_NAME:-video} -> ${FILE_SHARE_LINK}"
      #     API_URL="https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage"


      #     echo "\n"
      #     echo "$TEXT"
      #     echo "\n"

      #     curl -s -X POST "$API_URL" \
      #      -F chat_id=$TELEGRAM_CHAT_ID \
      #      -F text="$TEXT" \
      #      -F parse_mode=Markdown
           

      #     echo "\nTelegram notification sent"

      - name: Execute on_finished command
        if: ${{ github.event.inputs.on_finished != '' }}
        shell: sh
        env:
          FILENAME: ${{ github.event.inputs.filename || '' }}
          FILE_SHARE_LINK: ${{ env.FILE_SHARE_LINK || '' }}
        run: |
          set -eu
          echo "Executing custom on_finished command:"
          echo "${{ github.event.inputs.on_finished }}"
          eval "${{ github.event.inputs.on_finished }}"
