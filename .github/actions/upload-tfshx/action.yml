name: Upload TFSHx
description: Upload a file to TFSH and output the retrieval URL

inputs:
  file_path:
    description: Path to the file to upload
    required: true
  base_url:
    description: Base URL of the TFSH instance (e.g., https://tfshx.uripsub.dev)
    required: false
    default: https://tfshx.uripsub.dev
  max_days:
    description: Retention in days (sent via Max-Days header)
    required: false
    default: '1'
  method:
    description: Upload method, one of 'put' or 'multipart'
    required: false
    default: put
  origin_url:
    description: Optional direct/origin URL to bypass CDN if large files hit 413
    required: false

outputs:
  uploaded_url:
    description: Final TFSH URL with /get/ path
    value: ${{ steps.upload.outputs.uploaded_url }}

runs:
  using: composite
  steps:
    - name: Upload File
      id: upload
      shell: bash
      env:
        # Prefer input; defaults to public instance if unset.
        TFSH_BASE_URL: ${{ inputs.base_url }}
        TFSH_ORIGIN_URL: ${{ inputs.origin_url }}
        TFSH_METHOD: ${{ inputs.method }}
        TFSH_MAX_DAYS: ${{ inputs.max_days }}
      run: |
        set -euo pipefail

        urlencode() {
          local LC_ALL=C
          local s="$1"
          local i c
          for ((i=0; i<${#s}; i++)); do
            c=${s:i:1}
            case "$c" in
              [a-zA-Z0-9.~_-]) printf '%s' "$c" ;;
              *) printf '%%%02X' "'${c}" ;;
            esac
          done
        }

        src_path="${{ inputs.file_path }}"
        if [[ ! -f "$src_path" ]]; then
          echo "Error: file not found: $src_path" >&2
          exit 2
        fi
        if [[ ! -r "$src_path" ]]; then
          echo "Error: file not readable: $src_path" >&2
          exit 2
        fi

        base_url="${TFSH_BASE_URL:-https://tfshx.uripsub.dev}"
        base_url_noslash="${base_url%/}"
        # If origin_url provided, prefer it for the actual upload to bypass CDN limits
        upload_base_url="${TFSH_ORIGIN_URL:-$base_url}"
        upload_base_url_noslash="${upload_base_url%/}"
        filename="$(basename -- "$src_path")"
        encoded_filename="$(urlencode "$filename")"
        dest_url="$upload_base_url_noslash/$encoded_filename"

        # Compute size for diagnostics
        file_size_bytes=$(stat -c '%s' "$src_path" 2>/dev/null || stat -f '%z' "$src_path" 2>/dev/null || echo 0)
        echo "Uploading: $filename (size: ${file_size_bytes} bytes) -> $dest_url"

        method="${TFSH_METHOD,,}"
        max_days="${TFSH_MAX_DAYS:-1}"

        # Perform upload and capture URL response
        try_put_upload() {
          curl -fsS --globoff \
            -H "Max-Days: ${max_days}" \
            --http1.1 \
            --no-buffer \
            --upload-file "$src_path" \
            "$dest_url"
        }

        try_multipart_upload() {
          # Some TFSH deployments accept multipart form uploads at base URL
          # and return the final URL in the response body.
          curl -fsS --globoff \
            -H "Max-Days: ${max_days}" \
            -F "file=@${src_path};filename=${filename}" \
            "$upload_base_url_noslash/"
        }

        uploaded_url=""
        http_code=""

        # Helper to run a command and capture body + HTTP code
        run_and_capture() {
          local out
          out=$(set -o pipefail; { "$@" -w '%{http_code}' || true; } | {
            body=""; code=""; while IFS= read -r -d '' -n 1 ch; do body+="$ch"; done; printf '%s' "$body"; }) || true
        }

        # First attempt: selected method
        echo "Method: ${method}"
        if [[ "$method" == "put" ]]; then
          if ! uploaded_url=$(try_put_upload); then
            status=$?
            echo "Upload via PUT failed (exit=$status)." >&2
            uploaded_url=""
          fi
        else
          if ! uploaded_url=$(try_multipart_upload); then
            status=$?
            echo "Upload via multipart failed (exit=$status)." >&2
            uploaded_url=""
          fi
        fi

        # If still empty, try fallback to alternate method
        if [[ -z "$uploaded_url" ]]; then
          if [[ "$method" == "put" ]]; then
            echo "Falling back to multipart..." >&2
            if ! uploaded_url=$(try_multipart_upload); then
              uploaded_url=""
            fi
          else
            echo "Falling back to PUT..." >&2
            if ! uploaded_url=$(try_put_upload); then
              uploaded_url=""
            fi
          fi
        fi

        # If still empty, inspect last HTTP status when possible by re-running light request
        if [[ -z "$uploaded_url" ]]; then
          # Quick probe with a small range if server supports it (will likely fail similarly on 413)
          probe_code=$(curl -sS -o /dev/null -w '%{http_code}' --globoff -H "Max-Days: ${max_days}" -X PUT --data-binary '' "$dest_url" || true)
          if [[ "$probe_code" == "413" ]]; then
            echo "Error: upload failed to $dest_url (HTTP 413: Payload Too Large)" >&2
            echo "Hint: This often indicates a CDN/proxy upload size limit (e.g., Cloudflare 100MB/1GB)." >&2
            echo "- Try setting 'origin_url' input to a direct/origin hostname that bypasses the CDN." >&2
            echo "- Or reduce file size/split, or adjust server/CDN limits." >&2
          else
            echo "Error: upload failed to $dest_url (status=${probe_code:-unknown})." >&2
          fi
          exit 3
        fi

        # Transform URL for tfsh retrieval path based on provided base URL
        base_prefix="$base_url_noslash/"
        base_get_prefix="$base_url_noslash/get/"
        if [[ "$uploaded_url" == "$base_prefix"* && "$uploaded_url" != "$base_get_prefix"* ]]; then
          uploaded_url="${uploaded_url/#$base_prefix/$base_get_prefix}"
        fi

        # If response points at origin host, rewrite to base_url/get/
        if [[ -n "${TFSH_ORIGIN_URL:-}" ]]; then
          origin_noslash="${TFSH_ORIGIN_URL%/}"
          origin_prefix="$origin_noslash/"
          if [[ "$uploaded_url" == "$origin_prefix"* ]]; then
            uploaded_url="${uploaded_url/#$origin_prefix/$base_get_prefix}"
          fi
        fi

        echo "uploaded_url=$uploaded_url" >> "$GITHUB_OUTPUT"
